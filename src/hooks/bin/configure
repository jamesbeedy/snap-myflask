#!/usr/bin/env python3
import os
import sys
import subprocess
from pathlib import Path


def snapctl_get(snap_config_value):
    """Get snap config from snapctl.
    
    Return python None is snapctl returns the empty string.
    """

    snapctl_out = subprocess.check_output(
        ["snapctl", "get", snap_config_value]
    ).decode().rstrip()

    if snapctl_out == "":
        snapctl_out = None

    return snapctl_out


def snapctl_set(snap_config_value):
    subprocess.check_output(
        ["snapctl", "set", snap_config_value]
    )


def run_bash(bash_string):
    return subprocess.check_output(
        bash_string.split()
    ).decode().rstrip()


def configure_munge():
    munge_key_path = Path(f"{os.environ['SNAP_COMMON']}/etc/munge/munge.key")
    munge_key_from_snap_config = snapctl_get("munge.key")
    munged_process = f"{os.environ['SNAP_INSTANCE_NAME']}.munged"

    # Define the events surrounding the configuration of the munge.key snap
    # config.
    #
    # If the snap config for the munge.key is set AND there is an existing
    # munge key in $SNAP_COMMON/etc/munge/munge.key, write the munge key
    # obtained from snapctl to the path and stop/start munged.
    # If the munge key in $SNAP_COMMON/etc/munge/munge.key and the key
    # obtained from snapctl get are identical, return.
    if munge_key_path.exists() and munge_key_from_snap_config is not None:
        munge_key_from_path = munge_key_path.read_text()
        if munge_key_path.read_text() != munge_key_from_snap_config:
            munge_key_path.chmod(0o700)
            munge_key_path.write_text(munge_key_from_snap_config)
        else:
            return
    # If the munge.key is not defined as a snap config AND the
    # $SNAP_COMMON/etc/munge/munge.key file does not exist, generate
    # a munge key and write it to the file.
    elif not munge_key_path.exists() and munge_key_from_snap_config is None:
        munge_key_path.write_text(os.urandom(1024))
    # Alas, if the munge.key is defined and the munge key file does not exist,
    # write the snap munge.key config to the munge key file.
    elif not munge_key_path.exists() and munge_key_from_snap_config is not None:
        munge_key_path.write_text(munge_key_from_snap_config)
    else:
        return

    # Set perms to 0400
    munge_key_path.chmod(0o400)

    # Restart munged
    for event in ["stop", "start"]:
        try:
            run_bash(f"snapctl {event} {munged_process}")
        except Exception:
            pass


def configure_snap_mode():
    snap_mode_path = Path(f"{os.environ['SNAP_COMMON']}/snap_mode")
    snap_mode_from_snap_config = snapctl_get("snap.mode")

    supported_snap_modes = [
        "slurmdbd",
        "slurmctld",
        "slurmd",
        "login",
        "all",
        "none",
    ]

    snap_mode_process_map = {
        "slurmdbd": ["slurmdbd", "mysql"],
        "slurmctld": ["slurmctld"],
        "slurmd": ["slurmd"],
        "login": [],
        "all": ["slurmdbd", "slurmctld", "slurmd", "mysql"],
        "none": [],
    ]

    def is_snap_mode_config_supported():
        if snap_mode_from_snap_config is not None and \
           snap_mode_from_snap_config in supported_snap_modes:
            return True
        return False

    if not is_snap_mode_config_supported():
        raise Exception

    if snap_mode_path.exists() and snap_mode_from_snap_config is not None:

        # If the snap.mode has changed AND is different then what we have
        # on disk:
        #     - stop all running processes
        #     - start only the processes which are supported by the snap.mode
        if snap_mode_path.read_text() != snap_mode_from_snap_config:
            # Kill them all (we may need to be more precise about which
            # process we kill)
            for snapped_process in snap_mode_process_map["all"]:
                try:
                    run_bash(f"snapctl stop {snapped_process}")
                except Exception:
                    pass

            # Write out the new snap mode
            snap_mode_path.write_text(snap_mode_from_snap_config)
            # Grab processes to start
            snapped_processes = \
                snap_mode_process_map[snap_mode_from_snap_config]

            # Start the processes used by the newly configured snap mode,
            # throw exception if we cannot start the process.
            for snapped_process in snapped_processes:
                try:
                    run_bash(f"snapctl start {snapped_process}")
                except Exception:
                    sys.exit(1)



if __name__ == "__main__":
    configure_munge()
    configure_snap_mode()
